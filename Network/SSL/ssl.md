# SSL

## 开头
openssl的地址： https://www.openssl.org/
openssl中文： https://www.openssl.net.cn/

## ssl协议版本
SSL 1.0  
SSL 2.0  
SSL 3.0  
TLS 1.0  
TLS 1.1  
TLS 1.2
SSL 1.0 --> TSL 1.2逐渐更新，TLS 1.2是近期的标准、  

## 安装
openssl官方没有提供二进制安装，需要自行下载源码编译安装。  
可以使用第三方编译好的文件，这样比较简单： http://slproweb.com/products/Win32OpenSSL.html 。

* win安装
  win安装完以后要记得添加环境变量。
## 密钥，签名，证书
* 密钥  
  使用对称加密，非对称加密等算法协商出来的公钥和私钥，用于对数据加解密。  
  对称加密算法：ECB，CBC，CFB等。  
  非对称加密算法：RSA、DSA、DH和ECC。  
  对称加密加密解密使用的是相同的密钥，而非对称加密加密解密时使用的不同的密钥，分为公钥（public key）和私钥(private key)。公钥可以公开，而私钥自己保存。由于非对称加密的密钥生成麻烦，所以无法做到一次一密，而且其加密速度很慢，无法对大量数据加密。因此最常用的使用场景就是数字签名和密码传输，用作数字签名时使用私钥加密，公钥解密；用作加密解密时，使用公钥加密，私钥解密。

* 数字签名  
  使用摘要算法计算出来的一个hash值，此hash值成为**摘要**。摘要算法是将任意长度的内容计算为一个固定长度的hash，例如MD5和SHA1。摘要算法是不可逆的，我们不可以从hash结果逆推回原文，因此，摘要算法可以用于验证数据完整性，校验数据是否被篡改。
  1. 服务端将要发给客户端的原始数据，先进行hash，得到内容的摘要，然后，服务器使用自己的私钥对hash进行加密，生成**数字签名**。
  2. 服务器再用自己的私钥对原文进行加密，然后把加密后的数据和数字签名一起发给客户端。
  3. 客户端收到数据后，取出数字签名，使用服务器对应的公钥对签名解密，得到原文的摘要。由于公私钥是匹配的，客户端的公钥能够解开数据，就证明此数据确实是服务端发送的。
  4. 客户端再对原文进行解密，然后，对原文进行hash，得到摘要，将摘要与上一步的摘要进行对比，如果两者一致，就证明原文未被篡改。  
  上面这些操作，涉及非对称加密和摘要计算，整个过程的计算是十分耗时的，通常不用来传输数据。这套数据交互的流程，一般用户交换密码——对称加密的密码，后续数据的传输，改为使用对称加密。
  客户端是怎么拿到服务器对应的公钥呢，这就涉及数字证书了。

* 数字证书  
  在数字签名的环节中，我们需要确保客户端正确拥有对方的公钥。但是，公钥是不能在网络上传递的，因为服务器和客户端交换公钥的时候，很可能就被劫持和篡改了。由此，就引出了数字证书的概念。
  当某一方（客户端或者服务器）想要发布自己的公钥时，它需要将自己的个人信息和公钥交给CA（Certificate Authority，证书颁发机构），CA使用自己的私钥对其进行加密，生成**数字证书**。
  1. 当某一方要传输数据时，实际需要携带 密文+数字签名+数字证书。
  2. 对方收到数据后，首先提取数字证书，并使用CA的公钥对证书进行解密，拿到证书里面的个人信息和公钥。
  3. 再使用证书里面的公钥对数字签名进行解密，得到hash。
  4. 再使用证书里面的公钥对密文进行解密，得到原文并计算hash，与上一步的hash进行比对。  
  在数据交换的过程中，服务器要用自己的私钥对数据进行加密再发送给客户端，同样的，客户端也要拿自己的私钥对数据进行加密，再发送给服务器。加密是双方都需要做的事。  
  CA是第三方机构，是可信的。  
  数字证书怎么获得呢，这个是系统预装的或者手动添加的。比如，微软的windows就预装了大量的数字证书，12306网站会要求我们手动下载并信任证书。
  
* 自签证书
  1. 生成ca私钥ca.key。  
   `openssl genrsa -des3 -out ca.key 2048`
  2. 使用私钥自签根证书ca.crt。  
   `openssl req -new -x509 -days 3650 -key ca.key -out ca.crt`
  3. 生成服务器私钥server.pem。  
   `openssl genrsa -des3 -out server.pem 1024`
  4. 生成服务器 签发请求server.csr。  
   `openssl rsa -in server.pem -out server.key`
  5. 使用根证书签发服务器证书server.crt。  
   `openssl x509 -req -sha256 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -days 3650 -out server.crt`
  6. 生成客户端私钥client.pem。  
   `openssl genrsa -des3 -out client.pem 2048`
  7. 生成客户端 签发请求client.csr。  
   `openssl req -new -key client.pem -out client-req.csr`
  8. 使用根证书签发客户端证书client.crt。  
   `openssl x509 -req -sha256 -in client-req.csr -CA ca.crt -CAkey ca.key -CAcreateserial -days 3650 -out client.crt`

* 浏览器https访问网站
  1. qq.com准备注册网站了，它先自己创建了一对公私钥，私钥自己保存在服务器上，公钥和个人信息一起去CA请求签发证书。
  2. 当浏览器请求访问qq.com时，首先会进行加密协商。
  3. 服务器使用自己的私钥加密数据，并把数字证书一并下发给浏览器。
  4. 浏览器使用本地的证书管理器，从CA颁发的受信列表中去解开服务器下发的证书，得到服务器公钥和网站信息。
  5. 若网站信息是不匹配的，则证明在访问非法网站，浏览器会告警。
  6. 若服务器下发的证书不在受信列表中，则表示此证书是其他人颁发的，浏览器也会告警。
  7. 若证书受信，那么浏览器就认为访问的网站是真实的qq.com，客户端从证书中解出qq.com的公钥，并拿此公钥解密数据。
  8. 之后，浏览器要回复服务器，回复的数据也需要加密，此时，浏览器使用证书的公钥加密，再发给服务器。
  9. 服务器使用自己的私钥解密，两端可以基于非对称加密协商出一个对称密钥。
  10. 随后，双方使用对称密钥对数据进行加密和数据交互。
  11. 大概的流程是这个样子，具体的细节可以通过wireshark抓包分析。
  12. 这只是一个单向认证的例子，也就是浏览器认证了服务端的证书，反过来，服务器也可以主动要去浏览器提供证书，服务器要主动辨识客户端的身份。

https握手流程。   
![20220505163755](https://raw.githubusercontent.com/LittleMali/docs/master/mdPics/20220505163755.png)

## 证书格式
  我们常见的证书有很多种类型，cer，crt，key，pem等，它们之期的关系是什么？  

* X.509  
  X.509 是证书标准，X.509证书的核心是根据RFC 5280进行编码和/或数字签名的数字文档。该标准规定了两种编码方式，一个是PEM编码，一个是DER编码。通常来讲采用PEM编码就使用.pem作为文件扩展名，采用DER编码就使用.der作为文件扩展名。除了这两种常见的编码方式以外，还有.crt、.cer、.p12等。
  * PEM编码：本质是base64编码。  
  `openssl x509 -in certificate.pem -text -noout`
  * DER编码：采用字节流编码。
  `openssl x509 -in certificate.der -inform der -text -noout`

  我们下面介绍证书文件扩展名。
* .pem  
  采用PEM编码格式的 X.509标准的证书文件扩展名。
* 再谈.pem  
  PEM文件可能包含任何内容，包括公钥，私钥或两者，因为PEM文件不是标准文件。实际上，PEM只意味着该文件包含base64编码的数据位。  
  通常，PEM文件包含base64编码的密钥或证书，其中包含-----BEGIN \<whatever\>-----和-----END \<whatever\>----形式的页眉和页脚行。随着时间的推移，<whatever>已经发展出许多可能性，包括私钥，公钥，X509证书，PKCS7数据，包含多个证书的文件，包含私钥和X509证书的文件，PKCS＃10证书签名请求等等。  
  在 \<openssl src\>/crypto/pem/pem.h 中定义了openss可以解码的列表，例如下面的两个示例。  
  `#define PEM_STRING_RSA "RSA PRIVATE KEY"`  
  `#define PEM_STRING_X509 "CERTIFICATE"`  
  再提一句，通常一个pem文件中只包含一个类型内容，但是，我们可以手动把额外的BEGIN-END内容拷贝到某个pem文件中，这样，一个pem就会包含多个内容。
* .der  
  采用DER编码格式的 X.509标准的证书文件扩展名。
* .crt  
  证书certificate的缩写，可以是PEM或者DER编码，常见于UNIX系统，在unix下一般多使用PEM编码。
* .cer  
  证书certificate的缩写，可以是PEM或者DER编码，常见于Windows系统，在Windows下一般多使用DER编码。
* .p12/.pfx  
  全称：PKCS #12，是公钥加密标准（Public Key Cryptography Standards，PKCS）系列的一种，可以将包含了公钥的X.509证书和证书对应的私钥以及其他相关信息打包为一个整体。简单理解：一份.p12文件 =  X.509证书 + 私钥。  
  对 unix 服务器来说,一般 CRT 和 KEY 是分开存放在不同文件中的，但 Windows 的 IIS 则将它们存在一个 PFX 文件中。PFX 通常会有一个“提取密码”，你想把里面的东西读取出来的话，它就要求你提供提取密码。
* .csr  
  全称Certificate Signing Request，即证书签名请求，它并不是证书的格式，而是用于向权威证书颁发机构（Certificate Authority, CA）获得签名证书的申请，其核心内容包含一个 RSA公钥和其他附带信息。  
  例如，某个公司向权威CA申请证书时，该公司会先生成一对公私钥，再把公钥和公司信息写入csr，拿着csr去CA签发证书。
* .key  
  通常用来存放一个 RSA 公钥或者私钥，它并非 X.509 证书格式，编码同样可能是 PEM，也可能是 DER。