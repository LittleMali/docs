# Linux代码架构设计

## 两个进程
我们的项目是带UI的，ui负责跟用户进行交互，是一个独立的进程。同时，还有一个服务进程service，service在后台运行，负责承担大部分的功能。

service进程由系统保活，我们将自己的进程添加到系统systemd服务。

ui进程可以由service进程保活，防止ui进程意外退出。

## 插件化结构

代码架构通常可以分为公共组件（Common Plugin），核心组件（Core Plugin）和业务组件（Business Plugin）。

* 公共组件：独立的基础功能封装，给其他组件使用，比如进程封装，文件封装，IPC通信等。
* 核心组件：整个软件可运行的基础框架，负责搭建起整个框架，同时，还负责基础功能的维护，比如，配置文件读写，网络操作，数据上报，进程监控，文件监控等。
* 业务插件：各个独立的业务模块，xx业务做了数据上报，xx业务要监控进程启动等。

业务插件：升级插件、安全插件，管控插件，登录插件等。  
核心组件：插件化框架、网络库插件、心跳插件、数据上报插件、进程监控插件，文件监控插件，流量监控插件等。  
公共组件：日志库、IPC、文件库、进程库、加解密、libcurl、http server等。  

## 设计思路
### 插件扩展结构
* 核心组件会加载业务插件，每个业务插件都是独立的，业务插件下又可以自行创建并加载自己的子插件。
* 插件再加载子插件，这样插件的逻辑可以做到尽可能单一，以后扩展的需要可以新增子插件，而不是在老插件上进行修改，符合开放封闭原则。

### IPC限制
* IPC仅用于进程间通信，在service进程内部，通过插件的接口调用来获取需要的数据和能力。
* IPC进一步封装为RPC，供进程间通信使用，ui向service请求数据等。

### 数据唯一性
* 信息只有一份，比如后台配置，由核心组件（ConfigPlugin）负责维护读写，ConfigPlugin提供Read接口，共service进程内其他插件调用，ConfigPlugin提供Write接口，供业务插件按需调用。ConfigPlugin内部加锁解决多线程读写问题。
* 各个模块不要通过cpp级别的引用来读写配置，一来不好维护，二来会有多线程/进程操作问题，尤其是多进程操作，这个难解。

### 插件间依赖
* 核心组件和公共组件均通过接口的形式对外提供能力，别的插件通过`IxxxPluginInterface->DoXXX(...)`的方式来调用能力。  
* 插件框架负责解决插件寻找问题，每个插件只管接口调用，不关心功能插件到底在哪里。
* 由于插件之间彼此依赖，所以，插件的加载是有顺序的，要注意先后依赖。

### 消息中心机制
* 避免IPC消息满天飞。每个插件还可以作为事件中心，负责对外派发消息。比如，对配置文件变更感兴趣的插件，可以注册监听机制 `IConfigPlugin->Listen(cfgName, callback)`，在有配置文件变更的时候，ConfigPlugin Dispatch通知到各个插件。