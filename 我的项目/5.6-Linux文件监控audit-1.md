# Linux文件监控audit-1

audit是系统调用的审计，利用audit实现文件监控实际是监控特定api的调用，比如open，rename等。因此，我们想要监控文件操作就需要识别出某个文件操作对应的api是什么。但是，Linux系统的文件操作实际是一系列系统调用（open、read、write、close...）等的组合。

例如，要拷贝一个文件，你可能需要使用 open 系统调用打开源文件和目标文件，使用 read 系统调用读取源文件的内容，使用 write 系统调用将内容写入目标文件，然后使用 close 系统调用关闭两个文件。这些操作通常会被封装在一个函数中，例如 C 标准库的 fread 和 fwrite 函数，或者更高级的库函数，例如 GLib 的 g_file_copy 函数。

所以，在Windows上的CopyFile和MoveFile这类操作，在Linux上其实找不到直接的系统调用可以一一对应。

所以，单靠audit来实现文件监控是比较麻烦的，但是，fanotify可以准确区分`文件创建，读取，写关闭，读关闭`这几个场景。但是，对于`文件重命名、文件移动、拷贝，删除`这几个场景，仅涉及有限的系统调用，这几个场景使用audit更合适。更准确的说，

```
======================create======================
2	open
83	mkdir
85	creat
86	link
88	symlink
165	mount
257	openat
258	mkdirat
259	mknodat
133	mknod
265	linkat
266	symlinkat
304	open_by_handle_at
```

```c
// 文件监控
enum class EFileEvent : int {
    None = 0,

    // fanotify
    Create = 0x01, // FAN_CLOSE_WRITE
    Read = 0x20, // FAN_ACCESS
    WriteClose = 0x40, // FAN_CLOSE_WRITE
    ReadClose = 0x80, // FAN_CLOSE_NOWRITE

    // audit
    Delete = 0x02, // -S unlink rmdir unmount2 unlikat
    Rename = 0x04, // -S rename renameat renameat2
    Move = 0x08, // same as Rename
    Copy = 0x10,  // -S tee dup dup2 dup3 copy_file_range
};
```

